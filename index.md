#  My  TypeScript  Journey: Earned Badges üèÜ

## Badges Overview

Here  is a  collection of badges I earned from  completing Microsoft  Learn's TypeScript modules:

1. **Get started with TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/EJ75D4UP?sharingId=DA9FD68DB292F140)
2. **Declare variable types in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/7ENBJWTZ?sharingId=DA9FD68DB292F140)
3. **Implement interfaces in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/BLM8YJSD?sharingId=DA9FD68DB292F140)
4. **Develop typed functions by using TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/4S23PZMK?sharingId=DA9FD68DB292F140)
5. **Declare and instantiate classes in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/DGQNVETJ?sharingId=DA9FD68DB292F140)
6. **Define generics in TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/FZUDZ4BX?sharingId=DA9FD68DB292F140)
7. **Access external libraries from TypeScript**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/UF5QMQ43?sharingId=DA9FD68DB292F140)
8. **Organize code using TypeScript namespaces**: [Badge](https://learn.microsoft.com/api/achievements/share/en-us/playoffthecuff-6444/UF5EJBE3?sharingId=DA9FD68DB292F140)

## Reflections

In the first module, I became acquainted with the purpose and advantages of TypeScript, the main of which for practical use are the development of large applications by a group of developers. I also installed the TypeScript transpiler from npm in global mode, became familiar with the parameters for calling it from the CLI, and tried to compile the JS file. Also useful in TypeScript is the ability to compile older versions of ECMAScript into code.

In the second module, I learned how to declare strongly typed variables with an explicit annotation of their type, and became familiar with the mechanics of implicit type definition and the classification of subtypes in TypeScript. Also of interest for practical use are type assertions and tuples for cases of deliberate circumvention of TypeScript restrictions and enumerations as the opposite case of a deliberate narrowing of flexibility to prevent errors. Similar cases also include intersections, unions, and literal types.

In the third module, I got acquainted with interfaces for describing an object with very convenient use in cases of creating many objects with one type of interface due to IntelliSense and the ability to extend them like classes in JS if necessary.

The fourth module talks about creating functions with parameter types, with which you can get automatic type checking, as well as checking the number of arguments received. When calling such functions, it is convenient to use autocompletion in an IDE that supports TypeScript. I also learned how to determine the type of a function via an interface or type alias.

The fifth module provides information about TypeScript classes. Working with them is practically no different from JS, you just need to take into account everything related to types described in the previous modules. The differences include access modifiers, which can be used to fine-tune the accessibility of class elements.

The sixth module describes generics - universal templates. With their help, you can increase the flexibility of the language if necessary, by specifying the type abstractly, but at the same time maintaining the ability to automatically check types.

The seventh module looks at organizing code using modules.
The practical application is the same as in JS. There is a convenient ability to compile into various types of modules, for example for Node.js or the browser. Also, using practical examples, I examined cases of importing third-party JS libraries and their use without defining types.

In the eighth module, I studied the organization of code in namespaces using practical problems of reorganizing code implemented in a global space. This approach can be useful in collective development, when members of a distributed team do not know each other‚Äôs naming conventions and in cases where it is necessary to obtain a single file with code after compilation, which modules do not allow.
